<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>network protocol</title>
    <link href="/2023/03/14/network/"/>
    <url>/2023/03/14/network/</url>
    
    <content type="html"><![CDATA[<h1 id="网络协议基本原理"><a href="#网络协议基本原理" class="headerlink" title="网络协议基本原理"></a>网络协议基本原理</h1><h2 id="面试要点"><a href="#面试要点" class="headerlink" title="面试要点"></a>面试要点</h2><ul><li>什么是<code>TCP/IP</code>?</li><li><code>TCP</code>建立连接为什么要三次握手，断开连接时为什么又要四次挥手呢？</li><li><code>SSL/TLS</code>握手过程？</li></ul><h2 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h2><h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h3><p><code>OSI</code>模型：Open System Interconnection，开放式系统互联。国际标准化组织（<code>ISO</code>）制定的理论模型。<br><img src="https://i.imgur.com/x3BCFW9.jpg"></p><h3 id="TCP-x2F-IP四层网络模型"><a href="#TCP-x2F-IP四层网络模型" class="headerlink" title="TCP&#x2F;IP四层网络模型"></a>TCP&#x2F;IP四层网络模型</h3><p><code>TCP/IP</code>模型：基于<code>OSI</code>建立的实际实现的模型。<br><img src="https://i.imgur.com/XCadbAE.png"></p><h3 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h3><table>    <tr>        <td>OSI七层模型</td>        <td>TCP/IP概念层模型</td>        <td>功能</td>        <td>TCP/IP协议族</td>    </tr>    <tr>        <td>应用层</td>        <td rowspan="3">应用层</td>        <td>文件传输，电子邮件，文件服务，虚拟终端</td>        <td>HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、TLS</td>    </tr>    <tr>        <td>表示层</td>        <td>数据格式化，代码转换，数据加密</td>        <td>XDR、ASN.1、NCP、TLS、ASCII</td>    </tr>    <tr>        <td>会话层</td>        <td>保证多个参与方之间交互的控制</td>    </tr>    <tr>        <td>传输层</td>        <td>传输层</td>        <td>为上层提供数据可靠性传输服务</td>        <td>TCP、UDP、RTP、SCTP、SPX、ATP、IL</td>    </tr>    <tr>        <td>网络层</td>        <td>网络层</td>        <td>创建统一协议，通过路由将多个网络连接起来</td>        <td>IP、ICMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25</td>    </tr>    <tr>        <td>数据链路层</td>        <td rowspan="2">网络接口层（链路层）</td>        <td>保证帧数据的传递</td>        <td>以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</td>    </tr>    <tr>        <td>物理层</td>        <td>处理字节流的传输</td>        <td>调制解调器、无线电、光纤</td>    </tr></table><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>应用层和内核互通的机制，就是通过socket系统调用。那socket属于那一层呢？其实它哪一层都不属于，它属于操作系统的概念，而非网络协议分层的概念。只不过操作系统选择对于网络协议的实现模式是，二到四层的处理代码在内核里面，七层的处理代码让应用自己去做，两者需要跨内核态和用户态通信，就需要一个系统调用完成这个衔接，这就是socket。</p><h3 id="ISO-x2F-OSI参考模型-数据处理流程"><a href="#ISO-x2F-OSI参考模型-数据处理流程" class="headerlink" title="ISO&#x2F;OSI参考模型 数据处理流程"></a>ISO&#x2F;OSI参考模型 数据处理流程</h3><p><img src="https://i.imgur.com/K9Wc4ka.png"></p><ul><li>应用程序处理：应用层会对程序进行编码处理，这些编码相当于表示层的功能，对于何时建立连接以及何时发送数据的管理就是会话层的功能。</li><li>传输层处理：已TCP为例，负责建立连接，发送数据以及断开连接。发送数据时需要在应用层数据头部加上TCP首部。</li><li>网络层处理：IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</li><li>网络接口层：</li></ul><h3 id="传输层中的TCP和UDP"><a href="#传输层中的TCP和UDP" class="headerlink" title="传输层中的TCP和UDP"></a>传输层中的TCP和UDP</h3><ul><li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</li><li>UDP 是无连接的， 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li><li>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</li><li>传输层TCP和UDP协议里面，都有端口的概念，不同的应用监听不同的端口。</li></ul><h3 id="针对TCP编程"><a href="#针对TCP编程" class="headerlink" title="针对TCP编程"></a>针对TCP编程</h3><p><img src="https://i.imgur.com/wT4bg8L.png"></p><h3 id="单工、半双工和全双工"><a href="#单工、半双工和全双工" class="headerlink" title="单工、半双工和全双工"></a>单工、半双工和全双工</h3><ul><li>单工：简单的说就是一方只能发信息，另方则只能收信息，通信是单向的。</li><li>半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。</li><li>全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。</li></ul><p><strong>注：</strong> TCP连接是全双工</p><h3 id="TCP握手与挥手"><a href="#TCP握手与挥手" class="headerlink" title="TCP握手与挥手"></a>TCP握手与挥手</h3><p><img src="https://i.imgur.com/IphUokf.png"></p><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。<br><img src="https://i.imgur.com/3tRawnN.png"></p><ul><li>第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。</li><li>第二次分手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。</li><li>第三次分手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。</li><li>第四次分手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</li></ul><blockquote><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。<br>由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是<em><strong>全双工</strong></em>模式。这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p></blockquote><h3 id="针对UDP编程"><a href="#针对UDP编程" class="headerlink" title="针对UDP编程"></a>针对UDP编程</h3><p><img src="https://i.imgur.com/CpoxnwA.png"><br>UDP是没有连接的，所以不需要三次握手，也就不需要调用listen和connect，但是UDP的交互仍然需要IP地址和端口号，因而也需要bind。对于UDP来讲，没有所谓的连接维护，也没有所谓的连接的发起方和接收方，甚至都不存在客户端和服务端的概念。大家都是客户端，也同时是服务端。只要有一个socket，多台机器就可以任意通信，不存在哪两台机器是属于一个连接的概念。因此，每一个UDP的socket都需要bind，。每次通信时，调用 sendto 和 recvfrom，都要传入 IP 地址和端口。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Consensus Algo of Raft</title>
    <link href="/2023/03/01/raft/"/>
    <url>/2023/03/01/raft/</url>
    
    <content type="html"><![CDATA[<h1 id="共识算法之Raft"><a href="#共识算法之Raft" class="headerlink" title="共识算法之Raft"></a>共识算法之Raft</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着区块链及分布式场景的广泛应用，如何确保服务在出现网络延时、宕机或者作恶等故障情况下仍然能够得到安全一致的世界状态。此时大量的共识机制、共识算法应运而生。我们可以根据可以容忍的故障类型将这些共识算法分成两个大类：</p><ul><li>宕机容错类算法（crash fault tolerant consensus algorithm），可以容忍网络丢包、时钟漂移、部分节点宕机这种节点为良性的错误。常见算法有<code>Paxos</code>、<code>Raft</code>等。</li><li>拜占庭容错类算法（byzantine fault tolerant consensus algorithm），可以容忍部分节点任意类型错误，包括节点作恶的情况。常见算法有<code>PBFT</code>、<code>Tbft</code>、中本聪共识等。</li></ul><p>本文主要介绍<code>Raft</code>共识算法，由于在考虑到<code>Paxos</code>的难理解性以及该算法在实际工程应用中难以实现的特性，<code>Raft</code>共识算法在保证算法安全、可靠、高效的同时，该算法最大的设计挑战就是可理解性，并且在工程上容易实现。</p><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p><code>Raft</code>是一种为了管理复制日志的一致性算法。它提供了和<code>Paxos</code>算法相同的功能和性能，但是它的算法结构和<code>Paxos</code>不同，使得<code>Raft</code>算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，<code>Raft</code>将一致性算法分解成了几个关键模块，例如领导人选举、日志复制、日志压缩和安全机制等。<code>Raft</code>算法比<code>Paxos</code>算法更加容易学习。<code>Raft</code>算法还包括一个新的机制来允许集群成员的动态改变，它利用大多数重叠来保证安全性。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><strong>强领导特性</strong>：和其他一致性算法相比，<code>Raft</code>算法使用一种更强的领导能力形式。比如，日志条目只从领导人发送给其他的服务器。这种方式简化了对复制日志的管理并且使得<code>Raft</code>算法更加易于理解。</li><li><strong>领导选举</strong>：<code>Raft</code>算法使用一个随机超时计时器来选举领导人。并且在成为领导人后通过发送心跳信息来显示自己的领导权威。这种方式在解决领导选举冲突的时候会更加简单快捷。</li><li><strong>集群成员变更</strong>：<code>Raft</code>算法使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以正常工作。</li></ul><p><strong>注：</strong> 通常的一致性算法都具有安全性、一致性及终止性。</p><h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><p><code>Raft</code>一致性算法是基于复制状态机的背景下提出来的。在这种背景下，一组服务器上的状态机产生相同状态的副本。并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。</p><p><img src="https://i.imgur.com/DwzIGNK.jpg"><br>每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序，每一个服务器都执行相同的指令序列。由于每个状态机都是确定的，所以每一个服务器执行日志操作指令都能产生相同的状态。</p><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><ul><li><code>Leader</code>（领导者）: 正常情况下，集群中只有一个<code>Leader</code>, 负责处理客户端的写请求、日志复制、向<code>Follower</code>定期发送心跳信息。</li><li><code>Follower</code> (跟随者) : <code>Follower</code>会从<code>Leader</code>接收日志并提交本地日志信息。正常情况下不会主动发出请求；当超过一定时间没有收到来自<code>Leader</code>的心跳信息，就会<code>election time out</code>，成为<code>Candidate</code>。</li><li><code>Candidate</code> (候选者) : 如果<code>Leader</code>宕机或者断开连接，会选出新的<code>Leader</code>节点。<code>Candidate</code>节点向其他节点发送请求投票的<code>RPC</code>消息，如果赢得了大多数选票，就成为 <code>Leader</code>。</li><li><img src="https://i.imgur.com/1J1oBlB.jpg"></li></ul><p><strong>注：</strong> 节点之间是通过<code>RPC</code>进行通信。</p><h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><p><code>Term</code>(任期)：时间被划分成一个个的任期，每个任期始于一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束，然后会进入到下一个任期继续选举。任期之间的切换可以在不同的时间不同的服务器上观察到。<br><img src="https://i.imgur.com/3LW8CnA.jpg"></p><h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>初始化启动时：所有节点都处于<code>Follower</code>状态，当有节点率先超时时，该节点就会变成<code>Candidate</code>状态。节点的任期会增加同时节点会给集群中的其他节点发送选举投票消息(<code>RequestVote RPC</code>)。当投票数量超过半数节点时，该节点就会变成<code>Leader</code>节点同时该节点会向集群中的其他节点发送心跳(<code>AppendEntries RPCs</code>)，不携带<code>log entries</code>。发送心跳的目的是为了显示自己的领导地位。<br><img src="https://i.imgur.com/9h7Gesw.png"><br>上述情况是比较正常的情况，其实当节点处于<code>Candidate</code>时会出现三种情况：</p><ul><li>该节点赢得大多数投票并成为<code>Leader</code>节点。</li><li>集群中其他节点赢得大多数投票并成为<code>Leader</code>节点。</li><li>这一轮中没有节点能胜出然后会进入下一轮选举。</li></ul><p><strong>注：</strong> 可通过<a href="https://raft.github.io/">Raft官网</a>动画演示上述几种情况。</p><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><h3 id="日志条目"><a href="#日志条目" class="headerlink" title="日志条目"></a>日志条目</h3><p>当<code>Leader</code>被选举出来后，它就可以为客户端服务，客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行地发起<code>AppendEntries RPCs</code>给其他的服务器，让他们复制这条日志条目。领导人会不断的重复尝试发送请求,直到所有的跟随者都最终存储了所有的日志条目。<br><img src="https://i.imgur.com/lkMGl8L.jpg"><br>日志由有序序号标记的条目组成。每个条目都包含创建时的任期号和一个状态机需要执行的指令。一个条目当可以安全地被应用到状态机中去的时候，就认为是可以提交了。日志的提交是由<code>Leader</code>决定的。</p><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><ul><li>客户端向<code>Leader</code>节点发送写入指令请求。</li><li><code>Leader</code>节点将基于指令创建新的日志条目并存入本地日志，与此同时，<code>Leader</code>节点通过<code>AppendEntries RPCs</code>向集群中的其他节点进行日志复制请求。</li><li><code>Follower</code>节点成功收到日志复制消息后存入本地日志，并应答成功，此时的日志还未真正提交。</li><li><code>Leader</code>节点收到大多数成功应答后开始将日志指令提交到状态机中执行并反馈给客户端写入成功的响应，于此同时，<code>Leader</code>节点向集群中其他节点发送<code>AppendEntries RPCs</code>时会携带新的<code>leaderCommit</code>，也就是<code>Leader</code>最新提交日志的索引，<code>Follower</code>会根据此信息同步提交本地相同索引日志。</li><li>当大多数日志条目被成功写入后就称这些日志条目为<code>committed entries</code>.</li></ul><p><img src="https://i.imgur.com/Ezttbfm.png"></p><h3 id="日志匹配特性"><a href="#日志匹配特性" class="headerlink" title="日志匹配特性"></a>日志匹配特性</h3><p><code>Raft</code>中日志匹配机制是用来维护不同服务器日志之间一致性，可预测性。同时它是安全性保证的重要环节。<code>Raft</code>日志匹配特性如下:</p><ul><li>如果在不同节点的日志中有两个条目拥有相同的索引及任期号，那么他们就存储了相同的指令。</li><li>如果在不同节点的日志中有两个条目拥有相同的索引及任期号，那么他们之前的所有日志条目也全部相同。</li></ul><p>在<code>Raft</code>算法中，<code>Leader</code>是通过强制<code>Follower</code>直接复制自己的日志来处理不一致问题的。这意味着在<code>Follower</code>中的冲突的日志条目会被<code>Leader</code>的日志覆盖。要使得<code>Follower</code>的日志和自己的日志状态保持一致，<code>Leader</code>必须找到最后两者达成一致的地方，然后删除<code>Follower</code>从那个点之后的所有日志条目，并发送自己在那个点之后的日志给<code>Follower</code>。所有的这些操作都在发送<code>AppendEntries RPCs</code>请求时进行的一致性检查时完成。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>如果一个<code>Follower</code>宕机了，同时<code>Leader</code>也已经提交了很多日志指令，然后这个<code>Follower</code>可能会被重新选举成为新的<code>Leader</code>,那么此时新的<code>Leader</code>会如何处理日志复制呢？<br>由于上面这种情况<code>Raft</code>算法在进行领导选举时会对即将成为<code>Leader</code>的节点做一些限制，具体限制如下：</p><ul><li>日志条目是单向传送，只能从<code>Leader</code>到<code>Follower</code>。</li><li>候选人想要赢得选举，必须包含已提交最新的日志条目。</li><li>如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</li></ul><h3 id="提交前任日志条目"><a href="#提交前任日志条目" class="headerlink" title="提交前任日志条目"></a>提交前任日志条目</h3><p>当前<code>Leader</code>并不知道之前的任期里日志是否已经被提交，即使这条日志已经被复制到了多数派的服务器上。根据<code>Raft</code>协议，这条日志是不能被直接提交的。</p><blockquote><p>A leader knows that an entry from its current term is committed once that entry is stored on a majority of the servers. If a leader crashes before committing an entry, future leaders will attempt to finish replicating the entry. However, a leader cannot immediately conclude that an entry from a previous term is committed once it is stored on a majority of servers.</p></blockquote><p><img src="https://i.imgur.com/IiWlWCv.png"></p><ul><li><p>a: <code>S1</code>是<code>Term:2</code>的<code>Leader</code>，复制了一条日志(<code>Term:2,Index:2</code>)到<code>S2</code>，同时它自己也写了一条日志(<code>Term:2,Index:2</code>)到本地。</p></li><li><p>b: <code>S1</code>此时宕机，<code>S5</code>获得<code>S3</code>、<code>S4</code>和<code>S5</code>的投票成为<code>Leader</code>，然后写了一条日志(<code>Term:3,Index:2</code>)到本地，此时日志都并未提交。</p></li><li><p>c: <code>S5</code>此时宕机，<code>S1</code>复活并且重新当选<code>Leader</code>(<code>Term:4</code>)，开始继续复制日志(<code>Term:2,Index:2</code>)到多数派服务器上(<code>S1</code>,<code>S2</code>,<code>S3</code>)上。然后又新写入一条日志(<code>Term:4,Index:3</code>)到本地,此时(<code>Term:2,Index:2</code>)和<code>(Term:4,Index:3</code>)上的日志并未提交。</p><blockquote><p>虽然(<code>Term:2,Index:2</code>)已经完成了多数派的复制，但是这条日志的<code>Term</code>是2，而当前的<code>S1</code>已经是<code>Term:4</code>的<code>Leader</code>，所有还不能直接提交。只有等到提交<code>Term</code>为4时任期内的日志(Term:4,Index:3)完成多数派复制后，才能把(<code>Term:4,Index:3</code>)和之前任期中的<code>Term:2,Index:2</code>）日志一并提交。</p></blockquote></li><li><p>d: 根据c，此时<code>S1</code>宕机，<code>S5</code>当选<code>Leader</code> (<code>Term &gt;= 5</code>,voted from<code>S2</code>,<code>S3</code>,<code>S4</code>,<code>S5</code>) ，并将日志(<code>Term:3,Index:2</code>)复制到其他所有节点并成功提交。</p></li><li><p>e: 根据c，此时(<code>Term4,Index:3</code>)及他前面所有的日志都已经提交了，如果这个时候S1才宕机，那么再重新选举<code>Leader</code>时，只有<code>S2</code>或者<code>S3</code>中的一个才能被选为新的<code>Leader</code>，证明<code>Raft</code>能够保证只要是在当前<code>Term</code>时成功完成多数派复制的日志肯定会被提交，且已提交的日志不可能被覆盖。</p></li></ul><p>但是在分布式系统中，网络不可靠是一个大概率的问题，情况(d)虽然发生的概率不高，但是只要系统运行的时间足够长，这种情况总是可以出现。为了处理(d)这种情况，<code>Raft</code>共识算法永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交，一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。</p><p>本文主要介绍<code>Raft</code>共识算法<code>Leader</code>选举，日志复制以及安全性等方面内容，更多如安全性论证、成员变更、日志压缩等方面内容可参考如下论文：<br>(1) <a href="https://raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a><br>(2) <a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf">https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
